
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#pragma once
#include <functional>
#include <algorithm>

#include "CfgBean.h"

namespace cfg {

 
    enum class AudioType
    {
        UNKNOWN = 0,
        ACC = 1,
        AIFF = 2,
    };

 


namespace test { 
    enum class AccessFlag
    {
        WRITE = 1,
        READ = 2,
        TRUNCATE = 4,
        NEW = 8,
        READ_WRITE = WRITE|READ,
    };

} 


namespace test { 
    enum class ETestQuality
    {
        /// <summary>
        /// 最高品质
        /// </summary>
        A = 1,
        /// <summary>
        /// 黑色的
        /// </summary>
        B = 2,
        /// <summary>
        /// 蓝色的
        /// </summary>
        C = 3,
        /// <summary>
        /// 最差品质
        /// </summary>
        D = 4,
    };

} 


 struct AutoImport1; 
namespace test { struct Shape; }
namespace test { struct Circle; }
namespace test2 { struct Rectangle; }
namespace test { struct TestExcelBean1; }
namespace test { struct TestExcelBean2; }
 struct vec2; 
 struct vec3; 
 struct vec4; 



struct AutoImport1 : public luban::CfgBean 
{
    static bool deserializeAutoImport1(::luban::ByteBuf& _buf, ::luban::SharedPtr<AutoImport1>& _out);

    virtual ~AutoImport1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 这是id
     */
    ::luban::int32 id;
    /**
     * 字段x1
     */
    bool x1;
    ::luban::int64 x5;
    ::luban::float32 x6;
    ::luban::int32 x8;
    ::luban::String x10;
    ::luban::SharedPtr<vec2> v2;
    ::luban::datetime t1;
    ::luban::Array<::luban::int32> k1;
    ::luban::Array<::luban::int32> k2;
    ::luban::HashMap<::luban::int32, ::luban::int32> k8;
    ::luban::Vector<::luban::SharedPtr<vec3>> k10;
    ::luban::Vector<::luban::SharedPtr<vec4>> k11;
    ::luban::SharedPtr<vec3> v11;

    static constexpr int __ID__ = -2092142499;

    int getTypeId() const override { return __ID__; }
};



namespace test {

struct Shape : public luban::CfgBean 
{
    static bool deserializeShape(::luban::ByteBuf& _buf, ::luban::SharedPtr<Shape>& _out);

    virtual ~Shape() {}

    bool deserialize(::luban::ByteBuf& _buf);


};

}

namespace test {

/**
 * 圆
 */
struct Circle : public test::Shape 
{
    static bool deserializeCircle(::luban::ByteBuf& _buf, ::luban::SharedPtr<Circle>& _out);

    virtual ~Circle() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 半径
     */
    ::luban::float32 radius;

    static constexpr int __ID__ = 2131829196;

    int getTypeId() const override { return __ID__; }
};

}

namespace test2 {

/**
 * 矩形
 */
struct Rectangle : public test::Shape 
{
    static bool deserializeRectangle(::luban::ByteBuf& _buf, ::luban::SharedPtr<Rectangle>& _out);

    virtual ~Rectangle() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 宽度
     */
    ::luban::float32 width;
    /**
     * 高度
     */
    ::luban::float32 height;

    static constexpr int __ID__ = 694982337;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

/**
 * 这是个测试excel结构
 */
struct TestExcelBean1 : public luban::CfgBean 
{
    static bool deserializeTestExcelBean1(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestExcelBean1>& _out);

    virtual ~TestExcelBean1() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 最高品质
     */
    ::luban::int32 x1;
    /**
     * 黑色的
     */
    ::luban::String x2;
    /**
     * 蓝色的
     */
    ::luban::int32 x3;
    /**
     * 最差品质
     */
    ::luban::float32 x4;

    static constexpr int __ID__ = -1738345160;

    int getTypeId() const override { return __ID__; }
};

}

namespace test {

/**
 * 这是个测试excel结构
 */
struct TestExcelBean2 : public luban::CfgBean 
{
    static bool deserializeTestExcelBean2(::luban::ByteBuf& _buf, ::luban::SharedPtr<TestExcelBean2>& _out);

    virtual ~TestExcelBean2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    /**
     * 最高品质
     */
    ::luban::int32 y1;
    /**
     * 黑色的
     */
    ::luban::String y2;
    /**
     * 蓝色的
     */
    ::luban::float32 y3;

    static constexpr int __ID__ = -1738345159;

    int getTypeId() const override { return __ID__; }
};

}



struct vec2 : public luban::CfgBean 
{
    static bool deserializevec2(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec2>& _out);

    virtual ~vec2() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;

    static constexpr int __ID__ = 3615518;

    int getTypeId() const override { return __ID__; }
};





struct vec3 : public luban::CfgBean 
{
    static bool deserializevec3(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec3>& _out);

    virtual ~vec3() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;
    ::luban::float32 z;

    static constexpr int __ID__ = 3615519;

    int getTypeId() const override { return __ID__; }
};





struct vec4 : public luban::CfgBean 
{
    static bool deserializevec4(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec4>& _out);

    virtual ~vec4() {}

    bool deserialize(::luban::ByteBuf& _buf);

    ::luban::float32 x;
    ::luban::float32 y;
    ::luban::float32 z;
    ::luban::float32 w;

    static constexpr int __ID__ = 3615520;

    int getTypeId() const override { return __ID__; }
};






class TbAutoImport1
{
    private:
    ::luban::HashMap<::luban::int32, ::luban::SharedPtr<AutoImport1>> _dataMap;
    ::luban::Vector<::luban::SharedPtr<AutoImport1>> _dataList;
    
    public:
    bool load(::luban::ByteBuf& _buf)
    {        
        int n;
        if (!_buf.readSize(n)) return false;
        for(; n > 0 ; --n)
        {
            ::luban::SharedPtr<AutoImport1> _v;
            if(!AutoImport1::deserializeAutoImport1(_buf, _v)) return false;
            _dataList.push_back(_v);
            _dataMap[_v->id] = _v;
        }
        return true;
    }

    const ::luban::HashMap<::luban::int32, ::luban::SharedPtr<AutoImport1>>& getDataMap() const { return _dataMap; }
    const ::luban::Vector<::luban::SharedPtr<AutoImport1>>& getDataList() const { return _dataList; }

    AutoImport1* getRaw(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second.get() : nullptr;
    }

    ::luban::SharedPtr<AutoImport1> get(::luban::int32 key)
    { 
        auto it = _dataMap.find(key);
        return it != _dataMap.end() ? it->second : nullptr;
    }

};



class Tables
{
    public:
     TbAutoImport1 TbAutoImport1;

    bool load(::luban::Loader<::luban::ByteBuf> loader)
    {
        ::luban::ByteBuf buf;
        buf.clear();
        if (!loader(buf, "tbautoimport1")) return false;
        if (!TbAutoImport1.load(buf)) return false;
        return true;
    }
};



}

