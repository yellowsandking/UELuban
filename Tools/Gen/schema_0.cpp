
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#include "schema.h"

namespace cfg {


bool AutoImport1::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(id)) return false;
    if (!_buf.readBool(x1)) return false;
    if(!_buf.readLong(x5)) return false;
    if(!_buf.readFloat(x6)) return false;
    if(!_buf.readInt(x8)) return false;
    if(!_buf.readString(x10)) return false;
    if(!vec2::deserializevec2(_buf, v2)) return false;
    if(!_buf.readLong(t1)) return false;
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); k1.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; k1.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); k2.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::int32 _e; if(!_buf.readInt(_e)) return false; k2.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, (::luban::int32)_buf.size()); k8.reserve(n * 3 / 2);for(int i = 0 ; i < n ; i++) { ::luban::int32 _k; if(!_buf.readInt(_k)) return false; ::luban::int32 _v; if(!_buf.readInt(_v)) return false; k8[_k] = _v;}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); k10.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<vec3> _e; if(!vec3::deserializevec3(_buf, _e)) return false; k10.push_back(_e);}}
    {::luban::int32 n; if(!_buf.readSize(n)) return false; n = std::min(n, ::luban::int32(_buf.size())); k11.reserve(n);for(int i = 0 ; i < n ; i++) { ::luban::SharedPtr<vec4> _e; if(!vec4::deserializevec4(_buf, _e)) return false; k11.push_back(_e);}}
    { bool _has_value_; if(!_buf.readBool(_has_value_)){return false;}  if(_has_value_) { v11.reset(); if(!vec3::deserializevec3(_buf, v11)) return false; } else { v11.reset(); } }

    return true;
}

bool AutoImport1::deserializeAutoImport1(::luban::ByteBuf& _buf, ::luban::SharedPtr<AutoImport1>& _out)
{
    _out.reset(LUBAN_NEW(AutoImport1));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::Shape::deserialize(::luban::ByteBuf& _buf)
{


    return true;
}

bool test::Shape::deserializeShape(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::Shape>& _out)
{
    int32_t id;
    if (!_buf.readInt(id)) return false;
    switch (id)
    {
        case test::Circle::__ID__: { _out.reset(LUBAN_NEW(test::Circle)); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
        case test2::Rectangle::__ID__: { _out.reset(LUBAN_NEW(test2::Rectangle)); if (_out->deserialize(_buf)) { return true; } else { _out.reset(); return false;} }
        default: { _out = nullptr; return false;}
    }
}


bool test::Circle::deserialize(::luban::ByteBuf& _buf)
{
    if (!test::Shape::deserialize(_buf))
    {
        return false;
    }

    if(!_buf.readFloat(radius)) return false;

    return true;
}

bool test::Circle::deserializeCircle(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::Circle>& _out)
{
    _out.reset(LUBAN_NEW(test::Circle));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test2::Rectangle::deserialize(::luban::ByteBuf& _buf)
{
    if (!test::Shape::deserialize(_buf))
    {
        return false;
    }

    if(!_buf.readFloat(width)) return false;
    if(!_buf.readFloat(height)) return false;

    return true;
}

bool test2::Rectangle::deserializeRectangle(::luban::ByteBuf& _buf, ::luban::SharedPtr<test2::Rectangle>& _out)
{
    _out.reset(LUBAN_NEW(test2::Rectangle));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestExcelBean1::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(x1)) return false;
    if(!_buf.readString(x2)) return false;
    if(!_buf.readInt(x3)) return false;
    if(!_buf.readFloat(x4)) return false;

    return true;
}

bool test::TestExcelBean1::deserializeTestExcelBean1(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestExcelBean1>& _out)
{
    _out.reset(LUBAN_NEW(test::TestExcelBean1));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool test::TestExcelBean2::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readInt(y1)) return false;
    if(!_buf.readString(y2)) return false;
    if(!_buf.readFloat(y3)) return false;

    return true;
}

bool test::TestExcelBean2::deserializeTestExcelBean2(::luban::ByteBuf& _buf, ::luban::SharedPtr<test::TestExcelBean2>& _out)
{
    _out.reset(LUBAN_NEW(test::TestExcelBean2));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vec2::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;

    return true;
}

bool vec2::deserializevec2(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec2>& _out)
{
    _out.reset(LUBAN_NEW(vec2));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vec3::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;
    if(!_buf.readFloat(z)) return false;

    return true;
}

bool vec3::deserializevec3(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec3>& _out)
{
    _out.reset(LUBAN_NEW(vec3));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}


bool vec4::deserialize(::luban::ByteBuf& _buf)
{

    if(!_buf.readFloat(x)) return false;
    if(!_buf.readFloat(y)) return false;
    if(!_buf.readFloat(z)) return false;
    if(!_buf.readFloat(w)) return false;

    return true;
}

bool vec4::deserializevec4(::luban::ByteBuf& _buf, ::luban::SharedPtr<vec4>& _out)
{
    _out.reset(LUBAN_NEW(vec4));
    if (_out->deserialize(_buf))
    {
        return true;
    }
    else
    { 
        _out.reset();
        return false;
    }
}

}

